---
output: rmarkdown::html_vignette
title: Dead Store Elimination
vignette: >
  %\VignetteIndexEntry{Dead Store Elimination}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r echo=FALSE, message=FALSE}
library("rco")
library("microbenchmark")
library("ggplot2")
autoplot.microbenchmark <- function(obj) {
  levels(obj$expr) <- paste0("Expr_", seq_along(levels(obj$expr)))
  microbenchmark:::autoplot.microbenchmark(obj)
}
speed_up <- function(obj) {
  levels(obj$expr) <- paste0("Expr_", seq_along(levels(obj$expr)))
  obj <- as.data.frame(obj)
  summaries <- do.call(rbind, by(obj$time, obj$expr, summary))
  res <- c()
  for (i in seq_len(nrow(summaries) - 1) + 1) {
    res <- rbind(res, summaries[1, ] / summaries[i, ])
  }
  rownames(res) <- levels(obj$expr)[-1]
  return(res)
}
```

# Dead Store Elimination

## Background

Dead Store Elimination is an optimization that intends to remove a local variable that is assigned a value but is not read by any subsequent instruction.

For instance, consider the following code:

```{r eval=FALSE}
foo <- function(x) {
  i <- 8818
  return(x ^ 3)
}
```

Variable `i` is never used, so this assignation could be removed, resulting in:

```{r eval=FALSE}
foo <- function(x) {
  8818 # could be removed by Dead Expression Elimination
  return(x ^ 3)
}
```

After applying other optimizations, such as [Constant Propagation](opt-constant-propagation.html), some variables become Dead Stores.

For example, consider:

```{r eval=FALSE}
foo <- function(x) {
  i <- 0
  n <- 8818
  res <- 0
  while (i < n) {
    res <- res + i
    i <- i + 1
  }
  return(res)
}
```

After Constant Propagation would return:

```{r eval=FALSE}
foo <- function(x) {
  i <- 0
  n <- 8818
  res <- 0
  while (i < 8818) {
    res <- res + i
    i <- i + 1
  }
  return(res)
}
```

And thus, `n` would become a Dead Store.

## Example

Consider the following (useless) example:

```{r}
code <- paste(
  "foo <- function(n) {",
  "  i <- 0",
  "  res <- 0",
  "  while (i < n) {",
  "    res <- res + i",
  "    i <- i + 1",
  "    a <- i + 1",
  "  }",
  "  res",
  "}",
  "foo(10000)",
  sep = "\n"
)
cat(code)
```

Then, the automatically optimized code would be:

```{r}
opt_code <- opt_dead_store(list(code))
cat(opt_code$codes[[1]])
```

And if we measure the execution time of each one, and the speed-up:

```{r message=FALSE}
bmark_res <- microbenchmark({
  eval(parse(text = code))
}, {
  eval(parse(text = opt_code))
})
autoplot(bmark_res)
speed_up(bmark_res)
```

## Implementation


## To-Do

<!-- * Remove not assigned expressions? -->

<!--   When coding, for debugging, sometimes instead of using `print` or `cat` we just write the expression. This causes that we get code as for example: -->

<!--   ```{r eval=FALSE} -->
<!--   foo <- function(x) { -->
<!--     x != 0 -->
<!--     return(100 / x) -->
<!--   } -->
<!--   ``` -->

<!--   Here, the expression `x != 0` would be evaluated each time we call the `foo` function, but would not have any effect as it is not assigned, nor printed. And thus, could be removed. -->

<!--   However, removing expressions could result in behaviour missmatches, for instance, the following two codes: -->

<!--   ```{r eval=FALSE} -->
<!--   foo <- function() { -->
<!--     x != 0 -->
<!--     return(100) -->
<!--   } -->
<!--   bar <- function() { -->
<!--     return(100) -->
<!--   } -->

<!--   foo() -->
<!--   bar() -->
<!--   ``` -->

<!--   The `foo` call would give an error, while the `bar` call would not. -->
